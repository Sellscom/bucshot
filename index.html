const express = require('express');
const app = express();
const http = require('http').Server(app);
const io = require('socket.io')(http, { cors: { origin: "*" } });

app.use(express.static(__dirname));

let waitingPlayer = null;
let rooms = {};
const ITEMS_POOL = ['Beer', 'Knife', 'Cigaretes', 'Handclifs', 'Lighter'];

io.on('connection', (socket) => {
    socket.on('join_game', (userData) => {
        if (waitingPlayer && waitingPlayer.id !== socket.id) {
            const roomId = `room_${waitingPlayer.id}_${socket.id}`;
            const p1Id = waitingPlayer.id;
            const p2Id = socket.id;

            rooms[roomId] = {
                players: [p1Id, p2Id],
                round: 1,
                magazine: generateMagazine(),
                hp: { [p1Id]: 3, [p2Id]: 3 },
                inv: { [p1Id]: generateItems(4), [p2Id]: generateItems(4) },
                turn: p1Id,
                dmg: 1
            };

            socket.join(roomId);
            waitingPlayer.join(roomId);

            io.to(p1Id).emit('init_game', { roomId, myInv: rooms[roomId].inv[p1Id], oppInv: rooms[roomId].inv[p2Id], turn: true });
            io.to(p2Id).emit('init_game', { roomId, myInv: rooms[roomId].inv[p2Id], oppInv: rooms[roomId].inv[p1Id], turn: false });
            waitingPlayer = null;
        } else {
            waitingPlayer = socket;
        }
    });

    socket.on('game_action', (data) => {
        const room = rooms[data.roomId];
        if (!room || room.turn !== socket.id) return;

        if (data.type === 'shoot') {
            const isLive = room.magazine.shift();
            let nextTurn = room.turn;

            if (isLive) {
                const victimId = data.target === 'self' ? socket.id : room.players.find(id => id !== socket.id);
                room.hp[victimId] -= room.dmg;
                nextTurn = room.players.find(id => id !== socket.id);
            } else {
                if (data.target === 'opp') nextTurn = room.players.find(id => id !== socket.id);
            }

            room.dmg = 1; // Сброс урона после любого выстрела
            room.turn = nextTurn;
            io.to(data.roomId).emit('action_result', {
                type: 'shoot', actor: socket.id, target: data.target, isLive, hp: room.hp, nextTurn
            });
            checkState(data.roomId);

        } else if (data.type === 'item') {
            const idx = room.inv[socket.id].indexOf(data.item);
            if (idx === -1) return;
            room.inv[socket.id].splice(idx, 1);

            let logData = { item: data.item, actor: socket.id };
            if (data.item === 'Beer') logData.extra = room.magazine.shift();
            if (data.item === 'Knife') room.dmg = 2;
            if (data.item === 'Cigaretes') room.hp[socket.id] = Math.min(3, room.hp[socket.id] + 1);

            io.to(data.roomId).emit('action_result', { type: 'item', logData, hp: room.hp });
        }
    });
});

function checkState(roomId) {
    const room = rooms[roomId];
    const dead = room.players.find(id => room.hp[id] <= 0);
    if (dead) {
        room.round++;
        if (room.round > 3) {
            io.to(roomId).emit('game_over', { winner: room.players.find(id => id !== dead) });
            delete rooms[roomId];
        } else {
            room.hp = { [room.players[0]]: 3, [room.players[1]]: 3 };
            room.magazine = generateMagazine();
            io.to(roomId).emit('next_round', { round: room.round, mag: room.magazine });
        }
    } else if (room.magazine.length === 0) {
        room.magazine = generateMagazine();
        io.to(roomId).emit('reload', { mag: room.magazine });
    }
}

function generateMagazine() {
    const s = Math.floor(Math.random() * 4) + 3;
    return Array(s).fill(false).map((_, i) => i < Math.ceil(s/2)).sort(() => Math.random() - 0.5);
}
function generateItems(n) { return Array(n).fill(0).map(() => ITEMS_POOL[Math.floor(Math.random() * ITEMS_POOL.length)]); }

http.listen(process.env.PORT || 3000);
